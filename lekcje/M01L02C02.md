### Rozdzia≈Ç M01L02C02: Tworzenie projektu BUN

W poprzednim rozdziale poznali≈õmy proces tworzenia projektu Node.js z TypeScript. Teraz czas na praktyczne por√≥wnanie - stworzymy analogiczny projekt u≈ºywajƒÖc BUN. Dziƒôki temu zobaczysz r√≥≈ºnice w podej≈õciu i zrozumiesz, dlaczego BUN zyskuje coraz wiƒôkszƒÖ popularno≈õƒá w≈õr√≥d programist√≥w TypeScript.

#### Inicjalizacja projektu BUN

BUN oferuje znacznie prostszy proces inicjalizacji projektu ni≈º Node.js. Tam gdzie Node.js wymaga instalacji dodatkowych narzƒôdzi do obs≈Çugi TypeScript, BUN ma wszystko wbudowane.

**Tworzenie nowego projektu:**

```bash
# Utw√≥rz nowy folder dla projektu
mkdir moj-projekt-bun
cd moj-projekt-bun

# Inicjalizacja projektu BUN
bun init
```

Podczas inicjalizacji BUN zapyta o kilka podstawowych informacji:
- **Package name**: nazwa pakietu (domy≈õlnie nazwa folderu)
- **Entry point**: g≈Ç√≥wny plik aplikacji (domy≈õlnie `index.ts` - zauwa≈º TypeScript!)

Kluczowa r√≥≈ºnica: BUN domy≈õlnie sugeruje `.ts` jako rozszerzenie pliku, podczas gdy Node.js defaultowo u≈ºywa `.js`.

**Por√≥wnanie z Node.js:**
```bash
# Node.js - wymaga wielu krok√≥w
npm init                    # tworzy package.json z .js
npm install typescript      # instalacja TypeScript
npm install @types/node     # instalacja typ√≥w
npm install ts-node        # narzƒôdzie do uruchamiania TS
npm install nodemon        # hot reload

# BUN - jeden krok
bun init                   # od razu z TypeScript support
```

#### Analiza package.json w BUN

Po inicjalizacji BUN tworzy plik `package.json`, kt√≥ry r√≥≈ºni siƒô od wersji Node.js w kilku kluczowych aspektach:

**Przyk≈Çad package.json z BUN:**
```json
{
  "name": "moj-projekt-bun",
  "module": "index.ts",
  "type": "module",
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "scripts": {
    "start": "bun run index.ts",
    "dev": "bun --watch index.ts"
  }
}
```

**Kluczowe r√≥≈ºnice w por√≥wnaniu z Node.js:**

1. **`"module": "index.ts"`** - BUN natywnie obs≈Çuguje TypeScript jako entry point
2. **`"type": "module"`** - domy≈õlnie ES modules (w Node.js czƒôsto u≈ºywamy CommonJS)
3. **`@types/bun`** - zamiast `@types/node`
4. **Brak dependencies** - TypeScript i podstawowe narzƒôdzia sƒÖ wbudowane w BUN

**Por√≥wnanie skrypt√≥w:**
```json
// Node.js package.json
{
  "scripts": {
    "start": "node dist/index.js",
    "dev": "nodemon --exec ts-node src/index.ts",
    "build": "tsc"
  }
}

// BUN package.json
{
  "scripts": {
    "start": "bun run index.ts",
    "dev": "bun --watch index.ts"
  }
}
```

Zauwa≈º, ≈ºe BUN nie wymaga kroku kompilacji - uruchamia pliki `.ts` bezpo≈õrednio.

#### Instalacja dependencies w BUN

BUN ma w≈Çasny, b≈Çyskawiczny package manager, kt√≥ry jest kompatybilny z ekosystemem npm:

**Podstawowe polecenia:**
```bash
# Instalacja z package.json
bun install

# Instalacja nowego pakietu
bun add express
bun add @types/express --dev

# Instalacja globalna
bun add -g some-cli-tool

# Usuwanie pakietu
bun remove package-name
```

**Por√≥wnanie szybko≈õci:**
Je≈õli w poprzednim rozdziale instalacja dependencies Node.js zajƒô≈Ça oko≈Ço 30-60 sekund, to samo w BUN zajmie 3-10 sekund. To r√≥≈ºnica, kt√≥rƒÖ odczujesz szczeg√≥lnie w wiƒôkszych projektach.

**Przyk≈Çad instalacji Express z TypeScript:**
```bash
# Node.js (4 oddzielne polecenia)
npm install express
npm install @types/express --save-dev
npm install @types/node --save-dev
npm install typescript --save-dev

# BUN (2 polecenia)
bun add express
bun add @types/express --dev
# @types/bun i TypeScript sƒÖ ju≈º dostƒôpne
```

#### Uruchamianie skrypt√≥w w BUN

BUN oferuje nƒõkolika sposob√≥w uruchamiania aplikacji, wszystkie znacznie szybsze ni≈º Node.js:

**Bezpo≈õrednie uruchamianie:**
```bash
# Uruchomienie pliku TypeScript
bun index.ts

# Uruchomienie z watch mode (automatyczny restart)
bun --watch index.ts

# Uruchomienie z hot reload
bun --hot index.ts
```

**Przez npm scripts:**
```bash
# Uruchomienie skryptu z package.json
bun run start
bun run dev

# Lub kr√≥cej (jak npm)
bun start
bun dev
```

**Kluczowe zalety BUN:**
- **Natywny TypeScript** - nie ma krok kompilacji
- **Hot reload** - wbudowany, nie wymaga nodemon
- **Szybki startup** - aplikacje uruchamiajƒÖ siƒô 2-3x szybciej

#### Praktyczny przyk≈Çad: pierwszy skrypt TypeScript

Stw√≥rzmy prosty skrypt, kt√≥ry pokazuje r√≥≈ºnice miƒôdzy Node.js a BUN:

**index.ts:**
```typescript
// BUN ma wbudowane APIs kompatybilne z Node.js + dodatkowe
console.log('üöÄ Uruchomiono z BUN!');

// Standardowe Node.js API
import { readFileSync } from 'fs';
import { join } from 'path';

// BUN-specific API dla lepszej wydajno≈õci
const file = Bun.file('package.json');
const packageJson = await file.json();

console.log(`üì¶ Nazwa projektu: ${packageJson.name}`);
console.log(`‚ö° Uruchomiono w: ${Date.now() - process.uptime() * 1000}ms`);

// Przyk≈Çad HTTP serwera (BUN ma wbudowany fetch)
const server = Bun.serve({
  port: 3000,
  fetch(req) {
    return new Response('Hello from BUN! üî•');
  },
});

console.log(`üåê Serwer dzia≈Ça na http://localhost:${server.port}`);
```

**Uruchomienie:**
```bash
bun index.ts
```

**Por√≥wnanie z Node.js:**
```typescript
// Node.js - wymaga≈Çby:
// 1. Kompilacji: tsc index.ts
// 2. Instalacji typ√≥w: npm install @types/node
// 3. Uruchomienia: node index.js
// Lub: npm install ts-node && npx ts-node index.ts
```

#### Por√≥wnanie wydajno≈õci: BUN vs Node.js

Przeprowad≈∫my prosty test wydajno≈õci:

**test-performance.ts:**
```typescript
console.time('Startup time');

// Test szybko≈õci startu
const iterations = 100000;
const numbers: number[] = [];

for (let i = 0; i < iterations; i++) {
  numbers.push(Math.random() * 100);
}

const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(`Suma ${iterations} liczb: ${sum.toFixed(2)}`);

console.timeEnd('Startup time');

// Test HTTP requests (BUN ma wbudowany fetch)
const response = await fetch('https://api.github.com/users/octocat');
const data = await response.json();
console.log(`GitHub user: ${data.name}`);
```

**Uruchomienie por√≥wnawcze:**
```bash
# BUN
time bun test-performance.ts

# Node.js (gdyby≈õmy mieli ts-node)
time npx ts-node test-performance.ts
```

Typowe wyniki:
- **BUN**: ~50-100ms startup
- **Node.js**: ~200-400ms startup

#### Lockfile: bun.lockb vs package-lock.json

BUN tworzy plik `bun.lockb` zamiast `package-lock.json`:

**R√≥≈ºnice:**
- **Format**: Binarny (szybszy) vs JSON (czytelny)
- **Rozmiar**: Znacznie mniejszy od package-lock.json
- **Szybko≈õƒá**: B≈Çyskawiczny parsing vs wolny JSON parsing

**Oba pliki nale≈ºy commitowaƒá do repozytorium** dla zapewnienia reproducible builds.

#### Kiedy u≈ºywaƒá BUN zamiast Node.js?

**U≈ºywaj BUN gdy:**
- ‚úÖ Tworzysz nowy projekt TypeScript
- ‚úÖ Chcesz szybkie iteracje developmentu
- ‚úÖ Wydajno≈õƒá startupu jest wa≈ºna
- ‚úÖ Potrzebujesz wbudowanej obs≈Çugi TypeScript
- ‚úÖ Pracujesz z modern APIs (fetch, WebStreams)

**Zosta≈Ñ przy Node.js gdy:**
- ‚ö†Ô∏è Projekt u≈ºywa legacy dependencies
- ‚ö†Ô∏è Potrzebujesz bardzo specific npm packages
- ‚ö†Ô∏è Pracujesz w zespole, kt√≥ry nie jest gotowy na zmianƒô
- ‚ö†Ô∏è Deploying na platformy, kt√≥re nie obs≈ÇugujƒÖ BUN

#### Podsumowanie

BUN oferuje znacznie prostsze i szybsze do≈õwiadczenie dla programist√≥w TypeScript:

**Kluczowe zalety:**
1. **Natywny TypeScript** - ≈ºadnej kompilacji, uruchamiaj `.ts` bezpo≈õrednio
2. **B≈Çyskawiczny package manager** - instalacja dependencies 5-10x szybsza
3. **Szybki startup** - aplikacje uruchamiajƒÖ siƒô 2-3x szybciej
4. **Wbudowane narzƒôdzia** - hot reload, bundler, test runner
5. **Modern APIs** - fetch, WebStreams, top-level await

**R√≥≈ºnice w workflow:**
- **Node.js**: `npm init` ‚Üí `npm install typescript @types/node ts-node` ‚Üí `npx ts-node index.ts`
- **BUN**: `bun init` ‚Üí `bun index.ts`

W nastƒôpnym rozdziale por√≥wnamy wydajno≈õƒá obu runtime'√≥w w praktycznych scenariuszach i nauczymy siƒô, kiedy wybieraƒá kt√≥re rozwiƒÖzanie dla konkretnych projekt√≥w.

---

**Zadanie praktyczne:** 
Stw√≥rz projekt BUN z prostym HTTP serverem, kt√≥ry odpowiada JSON-em z aktualnym czasem. Por√≥wnaj czas startupu z analogicznym projektem Node.js z poprzedniego rozdzia≈Çu.
