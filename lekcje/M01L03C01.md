### Rozdział M01L03C01: Zarządzanie pakietami npm

#### Wprowadzenie - Backend vs Frontend Package Management

Jeśli masz doświadczenie z Angular CLI, już znasz podstawy npm - jednak zarządzanie pakietami w projektach backend Node.js ma swoje specyficzne cechy i najlepsze praktyki, które różnią się od świata frontend development.

W Angular CLI większość decyzji dotyczących pakietów jest podejmowana automatycznie - framework zarządza aktualizacjami, wersjonowaniem i kompatybilnością. W świecie Node.js backend, masz pełną kontrolę i odpowiedzialność za każdy pakiet, co daje większą elastyczność, ale wymaga też głębszego zrozumienia ekosystemu npm.

**Kluczowe różnice:**
- **Security**: Pakiety backend mają bezpośredni dostęp do systemu plików i sieci
- **Bundle size**: Nie ma ograniczeń wielkości jak w frontend (brak bundlera)
- **Runtime dependencies**: Wszystkie pakiety mogą być potrzebne w produkcji
- **Long-running processes**: Pakiety muszą być stabilne w długotrwałych procesach

#### Instalacja lokalnych pakietów

Lokalne pakiety to dependencies zainstalowane w konkretnym projekcie, dostępne tylko w jego kontekście. To podstawowy sposób dodawania funkcjonalności do aplikacji Node.js.

##### Podstawowe polecenia instalacji

```bash
# Instalacja pakietu jako production dependency
npm install express

# Skrócona forma
npm i express

# Instalacja wielu pakietów jednocześnie
npm install express body-parser cors

# Instalacja konkretnej wersji
npm install express@4.18.2
```

##### Dependencies vs DevDependencies

W projektach backend rozróżnienie jest kluczowe dla optymalizacji deploymentów produkcyjnych:

```bash
# Production dependencies - potrzebne w runtime
npm install express typescript dotenv

# Development dependencies - tylko dla developmentu
npm install --save-dev @types/node @types/express nodemon ts-node

# Skrócone formy
npm i -D @types/node    # --save-dev
npm i -P express        # --save (production, domyślne)
```

**Przykład package.json po instalacji:**

```json
{
  "dependencies": {
    "express": "^4.18.2",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "@types/node": "^20.5.0",
    "@types/express": "^4.17.17",
    "typescript": "^5.1.6",
    "ts-node": "^10.9.1",
    "nodemon": "^3.0.1"
  }
}
```

##### Instalacja bez automatycznego zapisu do package.json

```bash
# Instalacja bez modyfikacji package.json
npm install express --no-save

# Przydatne do testowania pakietów przed dodaniem do projektu
```

#### Instalacja globalnych pakietów

Globalne pakiety to narzędzia CLI dostępne w całym systemie, niezależnie od konkretnego projektu. W backend development używa się ich rzadziej niż w frontend, ale mają swoje miejsce.

##### Kiedy używać globalnych pakietów:

```bash
# Narzędzia CLI używane w wielu projektach
npm install -g typescript     # Kompilator TS dla wszystkich projektów
npm install -g nodemon        # Hot reload dla development
npm install -g pm2            # Process manager dla produkcji

# Sprawdzenie zainstalowanych pakietów globalnych
npm list -g --depth=0
```

##### Best practice: Unikaj globalnych pakietów

Nowoczesne podejście faworyzuje lokalne instalacje z npx:

```bash
# Zamiast globalnego typescript
npx tsc --init

# Zamiast globalnego nodemon
npx nodemon app.ts

# Lub dodanie do package.json scripts:
"scripts": {
  "dev": "nodemon src/app.ts",
  "build": "tsc"
}
```

**Zalety lokalnych pakietów:**
- Różne projekty mogą używać różnych wersji
- Łatwiejsze zarządzanie w zespole
- Reproducible builds
- Mniej konfliktów wersji

#### Semantyczne wersjonowanie (SemVer)

Semantic Versioning to system numeracji wersji pakietów w formacie MAJOR.MINOR.PATCH (np. 2.1.4).

##### Rodzaje zmian wersji:

```json
{
  "dependencies": {
    "express": "4.18.2"
  }
}
```

- **MAJOR (4)**: Breaking changes - API może się zmienić
- **MINOR (18)**: Nowe funkcjonalności, backward compatible  
- **PATCH (2)**: Bug fixes, backward compatible

##### Operatory wersjonowania:

```json
{
  "dependencies": {
    "express": "4.18.2",        // Dokładnie ta wersja
    "lodash": "^4.17.21",       // Compatible release (≥4.17.21, <5.0.0)
    "moment": "~2.29.4",        // Reasonably close (≥2.29.4, <2.30.0)
    "axios": ">=1.0.0 <2.0.0",  // Zakres wersji
    "uuid": "*"                 // Najnowsza dostępna (nie zalecane)
  }
}
```

##### Praktyczne zasady wersjonowania dla backend:

```json
{
  "dependencies": {
    // Stabilne, popularne biblioteki - używaj ^
    "express": "^4.18.2",
    "lodash": "^4.17.21",
    
    // Mniej stabilne lub nowe biblioteki - używaj ~
    "some-new-lib": "~1.2.3",
    
    // Krytyczne dependencies - pin exact version
    "database-driver": "3.1.4"
  },
  "devDependencies": {
    // Dev tools - można używać ^ lub latest
    "@types/node": "^20.5.0",
    "typescript": "^5.1.6"
  }
}
```

#### package-lock.json vs bun.lockb

Lock files zapewniają reproducible installs - gwarantują, że wszyscy w zespole oraz środowisko produkcyjne używają identycznych wersji pakietów.

##### package-lock.json (npm)

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "my-app",
      "version": "1.0.0",
      "dependencies": {
        "express": "^4.18.2"
      }
    },
    "node_modules/express": {
      "version": "4.18.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
      "integrity": "sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==",
      "dependencies": {
        "accepts": "~1.3.8",
        // ... wszystkie sub-dependencies z exact versions
      }
    }
  }
}
```

**Charakterystyka npm lock file:**
- Plik JSON (czytelny dla ludzi)
- Większy rozmiar (~100KB - 1MB w dużych projektach)
- Zawiera integrity hashes dla security
- Tracked w git (zawsze commituj!)

##### bun.lockb (BUN)

```bash
# Binarny format - nie da się odczytać w edytorze tekstu
# Znacznie mniejszy rozmiar (~10-50KB)
# Szybsze parsowanie przez BUN
# Również tracked w git
```

**Charakterystyka BUN lock file:**
- Binarny format (szybszy parsing)
- Kompaktowy rozmiar
- Automatic integrity verification
- Cross-platform compatible

##### Współpraca między npm i BUN lock files:

```bash
# Projekt z npm może być zainstalowany przez BUN
bun install  # Odczyta package-lock.json i stworzy bun.lockb

# Projekt z BUN może być zainstalowany przez npm
npm install  # Zignoruje bun.lockb i stworzy package-lock.json
```

**Best practice:** W projektach zespołowych wybierz jeden package manager i trzymaj się go konsekwentnie.

#### Best Practices dla Dependencies

##### 1. Organizacja pakietów

```json
{
  "dependencies": {
    // Web framework
    "express": "^4.18.2",
    "cors": "^2.8.5",
    
    // Database
    "mongoose": "^7.4.3",
    "redis": "^4.6.7",
    
    // Utilities
    "lodash": "^4.17.21",
    "moment": "^2.29.4",
    
    // Configuration
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    // TypeScript
    "typescript": "^5.1.6",
    "@types/node": "^20.5.0",
    "@types/express": "^4.17.17",
    
    // Development tools
    "nodemon": "^3.0.1",
    "ts-node": "^10.9.1",
    
    // Testing
    "jest": "^29.6.2",
    "@types/jest": "^29.5.3"
  }
}
```

##### 2. Security best practices

```bash
# Regularne audyty security
npm audit

# Automatyczne naprawy bezpiecznych luk
npm audit fix

# Sprawdzanie outdated packages
npm outdated

# Update pakietów (ostrożnie!)
npm update
```

##### 3. Zarządzanie aktualizacjami

```bash
# Sprawdź które pakiety są przestarzałe
npm outdated

# Update tylko patch versions (bezpieczne)
npm update --save

# Manual update major versions (wymaga testowania!)
npm install express@latest
```

##### 4. .gitignore dla Node.js

```gitignore
# Dependencies
node_modules/

# Lock files (wybierz jeden approach)
# package-lock.json  # jeśli team używa tylko BUN
# bun.lockb          # jeśli team używa tylko npm

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.production

# Build output
dist/
build/
```

##### 5. Scripts w package.json

```json
{
  "scripts": {
    "dev": "nodemon src/app.ts",
    "build": "tsc",
    "start": "node dist/app.js",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "audit": "npm audit",
    "clean": "rm -rf dist node_modules"
  }
}
```

##### 6. Dependency management checklist

**Przed dodaniem nowego pakietu:**
- [ ] Sprawdź popularność (weekly downloads)
- [ ] Ostatnia aktualizacja (nie starsze niż 6 miesięcy)
- [ ] Liczba open issues vs closed
- [ ] TypeScript support (`@types/` lub built-in)
- [ ] Bundle size (dla production dependencies)
- [ ] License compatibility

**Przykład research pakietu:**

```bash
# Informacje o pakiecie
npm info express

# Sprawdź size
npm info express dist.unpackedSize

# Dependencies tree
npm ls express
```

#### Podsumowanie

Zarządzanie pakietami w Node.js backend wymaga świadomego podejścia i zrozumienia konsekwencji każdej decyzji. Kluczowe zasady do zapamiętania:

**🔑 Kluczowe zasady:**

1. **Dependencies**: Production vs Development - dbaj o właściwą kategoryzację
2. **Wersjonowanie**: Używaj ^ dla stabilnych pakietów, ~ dla mniej pewnych, exact dla krytycznych
3. **Lock files**: Zawsze commituj i używaj konsekwentnie w zespole  
4. **Security**: Regularne audyty i aktualizacje bezpieczeństwa
5. **Lokalne vs Globalne**: Preferuj lokalne pakiety z npx

**🚀 Następne kroki:**

W następnym rozdziale (M01L03C02) skonfigurujemy TypeScript dla projektów backend, co pozwoli nam w pełni wykorzystać type safety w środowisku serwerowym.

**💡 Wskazówka dla programistów Angular:**

W przeciwieństwie do Angular CLI, który zarządza większością dependencies automatycznie, w Node.js backend masz pełną kontrolę. To oznacza większą odpowiedzialność, ale też możliwość precyzyjnego dostosowania stacku technologicznego do potrzeb projektu.

