### RozdziaÅ‚ M01L03C01: ZarzÄ…dzanie pakietami npm

#### Wprowadzenie - Backend vs Frontend Package Management

JeÅ›li masz doÅ›wiadczenie z Angular CLI, juÅ¼ znasz podstawy npm - jednak zarzÄ…dzanie pakietami w projektach backend Node.js ma swoje specyficzne cechy i najlepsze praktyki, ktÃ³re rÃ³Å¼niÄ… siÄ™ od Å›wiata frontend development.

W Angular CLI wiÄ™kszoÅ›Ä‡ decyzji dotyczÄ…cych pakietÃ³w jest podejmowana automatycznie - framework zarzÄ…dza aktualizacjami, wersjonowaniem i kompatybilnoÅ›ciÄ…. W Å›wiecie Node.js backend, masz peÅ‚nÄ… kontrolÄ™ i odpowiedzialnoÅ›Ä‡ za kaÅ¼dy pakiet, co daje wiÄ™kszÄ… elastycznoÅ›Ä‡, ale wymaga teÅ¼ gÅ‚Ä™bszego zrozumienia ekosystemu npm.

**Kluczowe rÃ³Å¼nice:**
- **Security**: Pakiety backend majÄ… bezpoÅ›redni dostÄ™p do systemu plikÃ³w i sieci
- **Bundle size**: Nie ma ograniczeÅ„ wielkoÅ›ci jak w frontend (brak bundlera)
- **Runtime dependencies**: Wszystkie pakiety mogÄ… byÄ‡ potrzebne w produkcji
- **Long-running processes**: Pakiety muszÄ… byÄ‡ stabilne w dÅ‚ugotrwaÅ‚ych procesach

#### Instalacja lokalnych pakietÃ³w

Lokalne pakiety to dependencies zainstalowane w konkretnym projekcie, dostÄ™pne tylko w jego kontekÅ›cie. To podstawowy sposÃ³b dodawania funkcjonalnoÅ›ci do aplikacji Node.js.

##### Podstawowe polecenia instalacji

```bash
# Instalacja pakietu jako production dependency
npm install express

# SkrÃ³cona forma
npm i express

# Instalacja wielu pakietÃ³w jednoczeÅ›nie
npm install express body-parser cors

# Instalacja konkretnej wersji
npm install express@4.18.2
```

##### Dependencies vs DevDependencies

W projektach backend rozrÃ³Å¼nienie jest kluczowe dla optymalizacji deploymentÃ³w produkcyjnych:

```bash
# Production dependencies - potrzebne w runtime
npm install express typescript dotenv

# Development dependencies - tylko dla developmentu
npm install --save-dev @types/node @types/express nodemon ts-node

# SkrÃ³cone formy
npm i -D @types/node    # --save-dev
npm i -P express        # --save (production, domyÅ›lne)
```

**PrzykÅ‚ad package.json po instalacji:**

```json
{
  "dependencies": {
    "express": "^4.18.2",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "@types/node": "^20.5.0",
    "@types/express": "^4.17.17",
    "typescript": "^5.1.6",
    "ts-node": "^10.9.1",
    "nodemon": "^3.0.1"
  }
}
```

##### Instalacja bez automatycznego zapisu do package.json

```bash
# Instalacja bez modyfikacji package.json
npm install express --no-save

# Przydatne do testowania pakietÃ³w przed dodaniem do projektu
```

#### Instalacja globalnych pakietÃ³w

Globalne pakiety to narzÄ™dzia CLI dostÄ™pne w caÅ‚ym systemie, niezaleÅ¼nie od konkretnego projektu. W backend development uÅ¼ywa siÄ™ ich rzadziej niÅ¼ w frontend, ale majÄ… swoje miejsce.

##### Kiedy uÅ¼ywaÄ‡ globalnych pakietÃ³w:

```bash
# NarzÄ™dzia CLI uÅ¼ywane w wielu projektach
npm install -g typescript     # Kompilator TS dla wszystkich projektÃ³w
npm install -g nodemon        # Hot reload dla development
npm install -g pm2            # Process manager dla produkcji

# Sprawdzenie zainstalowanych pakietÃ³w globalnych
npm list -g --depth=0
```

##### Best practice: Unikaj globalnych pakietÃ³w

Nowoczesne podejÅ›cie faworyzuje lokalne instalacje z npx:

```bash
# Zamiast globalnego typescript
npx tsc --init

# Zamiast globalnego nodemon
npx nodemon app.ts

# Lub dodanie do package.json scripts:
"scripts": {
  "dev": "nodemon src/app.ts",
  "build": "tsc"
}
```

**Zalety lokalnych pakietÃ³w:**
- RÃ³Å¼ne projekty mogÄ… uÅ¼ywaÄ‡ rÃ³Å¼nych wersji
- Åatwiejsze zarzÄ…dzanie w zespole
- Reproducible builds
- Mniej konfliktÃ³w wersji

#### Semantyczne wersjonowanie (SemVer)

Semantic Versioning to system numeracji wersji pakietÃ³w w formacie MAJOR.MINOR.PATCH (np. 2.1.4).

##### Rodzaje zmian wersji:

```json
{
  "dependencies": {
    "express": "4.18.2"
  }
}
```

- **MAJOR (4)**: Breaking changes - API moÅ¼e siÄ™ zmieniÄ‡
- **MINOR (18)**: Nowe funkcjonalnoÅ›ci, backward compatible  
- **PATCH (2)**: Bug fixes, backward compatible

##### Operatory wersjonowania:

```json
{
  "dependencies": {
    "express": "4.18.2",        // DokÅ‚adnie ta wersja
    "lodash": "^4.17.21",       // Compatible release (â‰¥4.17.21, <5.0.0)
    "moment": "~2.29.4",        // Reasonably close (â‰¥2.29.4, <2.30.0)
    "axios": ">=1.0.0 <2.0.0",  // Zakres wersji
    "uuid": "*"                 // Najnowsza dostÄ™pna (nie zalecane)
  }
}
```

##### Praktyczne zasady wersjonowania dla backend:

```json
{
  "dependencies": {
    // Stabilne, popularne biblioteki - uÅ¼ywaj ^
    "express": "^4.18.2",
    "lodash": "^4.17.21",
    
    // Mniej stabilne lub nowe biblioteki - uÅ¼ywaj ~
    "some-new-lib": "~1.2.3",
    
    // Krytyczne dependencies - pin exact version
    "database-driver": "3.1.4"
  },
  "devDependencies": {
    // Dev tools - moÅ¼na uÅ¼ywaÄ‡ ^ lub latest
    "@types/node": "^20.5.0",
    "typescript": "^5.1.6"
  }
}
```

#### package-lock.json vs bun.lockb

Lock files zapewniajÄ… reproducible installs - gwarantujÄ…, Å¼e wszyscy w zespole oraz Å›rodowisko produkcyjne uÅ¼ywajÄ… identycznych wersji pakietÃ³w.

##### package-lock.json (npm)

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "my-app",
      "version": "1.0.0",
      "dependencies": {
        "express": "^4.18.2"
      }
    },
    "node_modules/express": {
      "version": "4.18.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
      "integrity": "sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==",
      "dependencies": {
        "accepts": "~1.3.8",
        // ... wszystkie sub-dependencies z exact versions
      }
    }
  }
}
```

**Charakterystyka npm lock file:**
- Plik JSON (czytelny dla ludzi)
- WiÄ™kszy rozmiar (~100KB - 1MB w duÅ¼ych projektach)
- Zawiera integrity hashes dla security
- Tracked w git (zawsze commituj!)

##### bun.lockb (BUN)

```bash
# Binarny format - nie da siÄ™ odczytaÄ‡ w edytorze tekstu
# Znacznie mniejszy rozmiar (~10-50KB)
# Szybsze parsowanie przez BUN
# RÃ³wnieÅ¼ tracked w git
```

**Charakterystyka BUN lock file:**
- Binarny format (szybszy parsing)
- Kompaktowy rozmiar
- Automatic integrity verification
- Cross-platform compatible

##### WspÃ³Å‚praca miÄ™dzy npm i BUN lock files:

```bash
# Projekt z npm moÅ¼e byÄ‡ zainstalowany przez BUN
bun install  # Odczyta package-lock.json i stworzy bun.lockb

# Projekt z BUN moÅ¼e byÄ‡ zainstalowany przez npm
npm install  # Zignoruje bun.lockb i stworzy package-lock.json
```

**Best practice:** W projektach zespoÅ‚owych wybierz jeden package manager i trzymaj siÄ™ go konsekwentnie.

#### Best Practices dla Dependencies

##### 1. Organizacja pakietÃ³w

```json
{
  "dependencies": {
    // Web framework
    "express": "^4.18.2",
    "cors": "^2.8.5",
    
    // Database
    "mongoose": "^7.4.3",
    "redis": "^4.6.7",
    
    // Utilities
    "lodash": "^4.17.21",
    "moment": "^2.29.4",
    
    // Configuration
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    // TypeScript
    "typescript": "^5.1.6",
    "@types/node": "^20.5.0",
    "@types/express": "^4.17.17",
    
    // Development tools
    "nodemon": "^3.0.1",
    "ts-node": "^10.9.1",
    
    // Testing
    "jest": "^29.6.2",
    "@types/jest": "^29.5.3"
  }
}
```

##### 2. Security best practices

```bash
# Regularne audyty security
npm audit

# Automatyczne naprawy bezpiecznych luk
npm audit fix

# Sprawdzanie outdated packages
npm outdated

# Update pakietÃ³w (ostroÅ¼nie!)
npm update
```

##### 3. ZarzÄ…dzanie aktualizacjami

```bash
# SprawdÅº ktÃ³re pakiety sÄ… przestarzaÅ‚e
npm outdated

# Update tylko patch versions (bezpieczne)
npm update --save

# Manual update major versions (wymaga testowania!)
npm install express@latest
```

##### 4. .gitignore dla Node.js

```gitignore
# Dependencies
node_modules/

# Lock files (wybierz jeden approach)
# package-lock.json  # jeÅ›li team uÅ¼ywa tylko BUN
# bun.lockb          # jeÅ›li team uÅ¼ywa tylko npm

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.production

# Build output
dist/
build/
```

##### 5. Scripts w package.json

```json
{
  "scripts": {
    "dev": "nodemon src/app.ts",
    "build": "tsc",
    "start": "node dist/app.js",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "audit": "npm audit",
    "clean": "rm -rf dist node_modules"
  }
}
```

##### 6. Dependency management checklist

**Przed dodaniem nowego pakietu:**
- [ ] SprawdÅº popularnoÅ›Ä‡ (weekly downloads)
- [ ] Ostatnia aktualizacja (nie starsze niÅ¼ 6 miesiÄ™cy)
- [ ] Liczba open issues vs closed
- [ ] TypeScript support (`@types/` lub built-in)
- [ ] Bundle size (dla production dependencies)
- [ ] License compatibility

**PrzykÅ‚ad research pakietu:**

```bash
# Informacje o pakiecie
npm info express

# SprawdÅº size
npm info express dist.unpackedSize

# Dependencies tree
npm ls express
```

#### Podsumowanie

ZarzÄ…dzanie pakietami w Node.js backend wymaga Å›wiadomego podejÅ›cia i zrozumienia konsekwencji kaÅ¼dej decyzji. Kluczowe zasady do zapamiÄ™tania:

**ğŸ”‘ Kluczowe zasady:**

1. **Dependencies**: Production vs Development - dbaj o wÅ‚aÅ›ciwÄ… kategoryzacjÄ™
2. **Wersjonowanie**: UÅ¼ywaj ^ dla stabilnych pakietÃ³w, ~ dla mniej pewnych, exact dla krytycznych
3. **Lock files**: Zawsze commituj i uÅ¼ywaj konsekwentnie w zespole  
4. **Security**: Regularne audyty i aktualizacje bezpieczeÅ„stwa
5. **Lokalne vs Globalne**: Preferuj lokalne pakiety z npx

**ğŸš€ NastÄ™pne kroki:**

W nastÄ™pnym rozdziale (M01L03C02) skonfigurujemy TypeScript dla projektÃ³w backend, co pozwoli nam w peÅ‚ni wykorzystaÄ‡ type safety w Å›rodowisku serwerowym.

**ğŸ’¡ WskazÃ³wka dla programistÃ³w Angular:**

W przeciwieÅ„stwie do Angular CLI, ktÃ³ry zarzÄ…dza wiÄ™kszoÅ›ciÄ… dependencies automatycznie, w Node.js backend masz peÅ‚nÄ… kontrolÄ™. To oznacza wiÄ™kszÄ… odpowiedzialnoÅ›Ä‡, ale teÅ¼ moÅ¼liwoÅ›Ä‡ precyzyjnego dostosowania stacku technologicznego do potrzeb projektu.

