### RozdziaÅ‚ M01L03C02: Konfiguracja TypeScript dla backend

W projektach Angular, konfiguracja TypeScript byÅ‚a w duÅ¼ej mierze ukryta za Angular CLI i automatycznie dostosowana do potrzeb aplikacji frontendowych. W Å›rodowisku backend Node.js, programista ma peÅ‚nÄ… kontrolÄ™ nad konfiguracjÄ… TypeScript - co oznacza wiÄ™kszÄ… elastycznoÅ›Ä‡, ale takÅ¼e koniecznoÅ›Ä‡ zrozumienia specyfiki projektÃ³w serwerowych.

#### Dlaczego konfiguracja backend jest inna niÅ¼ frontend?

Projekty backend majÄ… fundamentalnie inne wymagania niÅ¼ aplikacje frontendowe:

- **Åšrodowisko wykonania**: Node.js zamiast przeglÄ…darki
- **System moduÅ‚Ã³w**: CommonJS lub ES Modules zamiast bundlerÃ³w
- **Typy globalne**: Node.js API zamiast DOM API
- **Target compilation**: NajczÄ™Å›ciej najnowsza wersja Node.js zamiast kompatybilnoÅ›ci z przeglÄ…darkami
- **Build proces**: BezpoÅ›rednia kompilacja zamiast bundlingu

#### Instalacja niezbÄ™dnych dependencies

Aby skonfigurowaÄ‡ TypeScript w projekcie Node.js, potrzebujemy kilku kluczowych pakietÃ³w:

```bash
# GÅ‚Ã³wne dependencies dla TypeScript
npm install --save-dev typescript @types/node

# NarzÄ™dzia deweloperskie dla wygody
npm install --save-dev ts-node nodemon

# Opcjonalnie: dla formatowania i lintingu
npm install --save-dev prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

**WyjaÅ›nienie pakietÃ³w:**
- `typescript` - kompilator TypeScript
- `@types/node` - definicje typÃ³w dla Node.js API (fs, path, process, itp.)
- `ts-node` - bezpoÅ›rednie uruchamianie plikÃ³w `.ts` bez kompilacji
- `nodemon` - automatyczny restart aplikacji przy zmianach w plikach

#### Tworzenie tsconfig.json dla projektÃ³w serwerowych

W przeciwieÅ„stwie do Angular CLI, ktÃ³ry generuje `tsconfig.json` automatycznie, w projektach Node.js tworzymy go rÄ™cznie:

```bash
# Generowanie podstawowego tsconfig.json
npx tsc --init
```

Jednak podstawowa konfiguracja wymaga dostosowania do specyfiki backend. Oto przykÅ‚ad `tsconfig.json` dla projektu Node.js:

```json
{
  "compilerOptions": {
    // Target i moduÅ‚y
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    
    // Output i organizacja
    "outDir": "./dist",
    "rootDir": "./src",
    "removeComments": true,
    
    // Module resolution
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    
    // Type checking
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    
    // Decorators (jeÅ›li uÅ¼ywane)
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    
    // Source maps dla debugowania
    "sourceMap": true,
    "inlineSources": true,
    
    // Path mapping (opcjonalne)
    "baseUrl": "./",
    "paths": {
      "@/*": ["src/*"],
      "@models/*": ["src/models/*"],
      "@services/*": ["src/services/*"]
    }
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts"
  ]
}
```

#### Kluczowe rÃ³Å¼nice wzglÄ™dem konfiguracji Angular

| Opcja | Angular (Frontend) | Node.js (Backend) | Dlaczego? |
|-------|-------------------|-------------------|-----------|
| `target` | ES2015-ES2020 | ES2022+ | Node.js obsÅ‚uguje najnowsze features |
| `module` | ES2015/ES2020 | CommonJS | Node.js domyÅ›lnie uÅ¼ywa CommonJS |
| `lib` | DOM, ES6+ | ES2022 | Backend nie potrzebuje DOM typÃ³w |
| `outDir` | Bundler zarzÄ…dza | `./dist` | BezpoÅ›rednia kompilacja do folderu |
| `moduleResolution` | Bundler zarzÄ…dza | `node` | ZgodnoÅ›Ä‡ z Node.js resolution |

#### Konfiguracja ES Modules (nowoczesne podejÅ›cie)

JeÅ›li chcesz uÅ¼ywaÄ‡ ES Modules zamiast CommonJS, potrzebujesz dwÃ³ch zmian:

**1. W `package.json` dodaj:**
```json
{
  "type": "module"
}
```

**2. W `tsconfig.json` zmieÅ„:**
```json
{
  "compilerOptions": {
    "module": "ES2022",
    "target": "ES2022"
  }
}
```

#### Workflow kompilacji i uruchamiania

**Opcja 1: Kompilacja + uruchomienie (produkcja)**
```bash
# Kompilacja TypeScript do JavaScript
npx tsc

# Uruchomienie skompilowanego kodu
node dist/index.js
```

**Opcja 2: BezpoÅ›rednie uruchomienie (development)**
```bash
# Uruchomienie bez kompilacji za pomocÄ… ts-node
npx ts-node src/index.ts
```

**Opcja 3: Watch mode z automatycznym restartem**
```bash
# Kombinacja ts-node + nodemon
npx nodemon --exec "ts-node src/index.ts"
```

#### Konfiguracja scripts w package.json

Dodaj wygodne skrypty do `package.json`:

```json
{
  "scripts": {
    "dev": "nodemon --exec ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "clean": "rm -rf dist",
    "type-check": "tsc --noEmit"
  }
}
```

#### Praktyczny przykÅ‚ad: pierwszy skrypt TypeScript

StwÃ³rz `src/index.ts`:

```typescript
import { readFileSync } from 'fs';
import { join } from 'path';

// PrzykÅ‚ad wykorzystujÄ…cy Node.js API
function readPackageJson(): any {
  const packagePath = join(process.cwd(), 'package.json');
  const packageContent = readFileSync(packagePath, 'utf-8');
  return JSON.parse(packageContent);
}

function main(): void {
  console.log('ðŸš€ TypeScript + Node.js dziaÅ‚a!');
  
  const packageInfo = readPackageJson();
  console.log(`Projekt: ${packageInfo.name}`);
  console.log(`Wersja: ${packageInfo.version}`);
  
  // PrzykÅ‚ad pracy z process.argv
  const args = process.argv.slice(2);
  if (args.length > 0) {
    console.log(`Argumenty: ${args.join(', ')}`);
  }
}

// Export dla testÃ³w
export { readPackageJson };

// Uruchomienie tylko jeÅ›li to gÅ‚Ã³wny moduÅ‚
if (require.main === module) {
  main();
}
```

Uruchom skrypt:
```bash
npm run dev
# lub
npm run dev -- argument1 argument2
```

#### Debugowanie TypeScript w VS Code

StwÃ³rz `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug TypeScript",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/src/index.ts",
      "runtimeArgs": ["-r", "ts-node/register"],
      "env": {
        "NODE_ENV": "development"
      },
      "sourceMaps": true,
      "cwd": "${workspaceFolder}",
      "protocol": "inspector"
    }
  ]
}
```

#### Najlepsze praktyki dla projektÃ³w backend

1. **Organizacja typÃ³w**: StwÃ³rz folder `src/types/` dla custom typÃ³w
2. **Environment variables**: UÅ¼ywaj `process.env` z proper typing
3. **Path mapping**: Skonfiguruj alias dla czytelniejszych imports
4. **Strict mode**: Zawsze wÅ‚Ä…czaj strict mode dla better type safety
5. **Source maps**: WÅ‚Ä…cz dla Å‚atwiejszego debugowania

#### PrzykÅ‚ad organizacji projektu

```
my-backend-project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ types/           # Custom type definitions
â”‚   â”œâ”€â”€ models/          # Data models
â”‚   â”œâ”€â”€ services/        # Business logic
â”‚   â”œâ”€â”€ routes/          # API routes
â”‚   â”œâ”€â”€ utils/           # Helper functions
â”‚   â””â”€â”€ index.ts         # Entry point
â”œâ”€â”€ dist/                # Compiled JavaScript (generated)
â”œâ”€â”€ tsconfig.json        # TypeScript configuration
â”œâ”€â”€ package.json         # Dependencies i scripts
â””â”€â”€ .env                 # Environment variables
```

#### RozwiÄ…zywanie typowych problemÃ³w

**Problem: "Cannot find module" dla Node.js built-ins**
```bash
# Upewnij siÄ™, Å¼e masz @types/node
npm install --save-dev @types/node
```

**Problem: Import errors przy ES Modules**
```typescript
// Zamiast:
import fs from 'fs';

// UÅ¼yj:
import { readFileSync } from 'fs';
```

**Problem: Source maps nie dziaÅ‚ajÄ…**
SprawdÅº czy masz wÅ‚Ä…czone w `tsconfig.json`:
```json
{
  "compilerOptions": {
    "sourceMap": true,
    "inlineSources": true
  }
}
```

#### Podsumowanie

Konfiguracja TypeScript dla projektÃ³w backend Node.js rÃ³Å¼ni siÄ™ znaczÄ…co od projektÃ³w Angular. Kluczowe rÃ³Å¼nice to:

- **Manual setup**: Programista ma peÅ‚nÄ… kontrolÄ™ nad konfiguracjÄ…
- **Node.js specific**: Target i module ustawienia dostosowane do Å›rodowiska serwerowego  
- **Different types**: @types/node zamiast DOM types
- **Flexible workflow**: MoÅ¼liwoÅ›Ä‡ wyboru miÄ™dzy kompilacjÄ… a ts-node
- **Production ready**: Konfiguracja musi uwzglÄ™dniaÄ‡ deployment

Po skonfigurowaniu TypeScript dla backend, otrzymujesz wszystkie korzyÅ›ci type safety znanego z Angular, ale w kontekÅ›cie programowania serwerowego. W nastÄ™pnych rozdziaÅ‚ach bÄ™dziemy wykorzystywaÄ‡ tÄ™ konfiguracjÄ™ do budowania prawdziwych aplikacji backend.

**Co dalej?** W nastÄ™pnym module przejdziemy do praktycznego programowania - utworzymy pierwsze skrypty TypeScript wykorzystujÄ…ce Node.js API do operacji na plikach i podstawowych zadaÅ„ serwerowych.
